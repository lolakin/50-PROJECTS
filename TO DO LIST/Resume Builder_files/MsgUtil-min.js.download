var MsgUtil = MsgUtil || {}; MsgUtil = function () { var t, e, r = { KeyMethod: "none" }, n = { sedk: "", siv: "", cedk: "", civ: "", ks: 16 }, i = function (t, e, r) { var n; return null == t || 0 == t ? ((n = new Date).setUTCHours(0, 0, 0, 0), n.setUTCFullYear(1988, 11, 5), n) : ((n = new Date).setUTCHours(0, 0, 0, 0), n.setUTCFullYear(t, e, r), n) }, o = function (t) { if (!MsgUtil.isInitializationDone) throw new Error("MsgUtil Config not set."); var e = new Promise(function (e, r) { var i, o, s; null != t && "" != t || e(""), (s = new Promise(function (t, e) { t(f.enc.Utf8.parse(n.cedk)) }), s.catch(function (t) { throw console.log("%c MsgUtil->Enc Key Failed. Error is -  " + t.message, "background: Yellow;color:Red"), t }), s).then(function (t) { i = t }).then(function () { return (t = new Promise(function (t, e) { t(f.enc.Utf8.parse(n.civ)) })).catch(function (t) { throw console.log("%c MsgUtil->Enc IV Failed. Error is -  " + t.message, "background: Yellow;color:Red"), t }), t; var t }).then(function (t) { o = t }).then(function () { var r = f.AES.encrypt(f.enc.Utf8.parse(t), i, { keySize: n.ks, iv: o, mode: f.mode.CBC, padding: f.pad.Pkcs7 }).toString(); e(r) }) }); return e.catch(function (t) { throw console.log("%c MsgUtil->EncryptData Failed. Error is -  " + t.message, "background: Yellow;color:Red"), t }), e }, s = function (t) { if (!MsgUtil.isInitializationDone) throw new Error("MsgUtil Config not set."); var e = new Promise(function (e, r) { var i, o, s; null != t && "" != t || e(""), (s = new Promise(function (t, e) { t(f.enc.Utf8.parse(n.sedk)) }), s.catch(function (t) { throw console.log("%c MsgUtil->Dcr Key  Failed. Error is -  " + t.message, "background: Yellow;color:Red"), t }), s).then(function (t) { i = t }).then(function () { return (t = new Promise(function (t, e) { t(f.enc.Utf8.parse(n.siv)) })).catch(function (t) { throw console.log("%c MsgUtil->Dcr IV Failed. Error is -  " + t.message, "background: Yellow;color:Red"), t }), t; var t }).then(function (t) { o = t }).then(function () { try { var s = f.AES.decrypt(t, i, { keySize: n.ks, iv: o, mode: f.mode.CBC, padding: f.pad.Pkcs7 }).toString(f.enc.Utf8) } catch (t) { r(new Error("Decryption failed due to bad key")) } e(s) }) }); return e.catch(function (t) { throw console.log("%c MsgUtil->DecryptData Failed. Error is -  " + t.message, "background: Yellow;color:Red"), t }), e }, c = function (t, e) { n.sedk = t, n.siv = t, n.cedk = e, n.civ = e, MsgUtil.isInitializationDone = !0, r.KeyMethod = "direct" }, a = function (t) { var e, r = (e = function (t) { for (var e = [], r = 0, n = 0; n < t.length; n++) { var i = t.charCodeAt(n); i < 128 ? e[r++] = i : i < 2048 ? (e[r++] = i >> 6 | 192, e[r++] = 63 & i | 128) : 55296 == (64512 & i) && n + 1 < t.length && 56320 == (64512 & t.charCodeAt(n + 1)) ? (i = 65536 + ((1023 & i) << 10) + (1023 & t.charCodeAt(++n)), e[r++] = i >> 18 | 240, e[r++] = i >> 12 & 63 | 128, e[r++] = i >> 6 & 63 | 128, e[r++] = 63 & i | 128) : (e[r++] = i >> 12 | 224, e[r++] = i >> 6 & 63 | 128, e[r++] = 63 & i | 128) } return e }(t), Array.from(e, function (t) { return t.toString(16).padStart(2, "0") }).join("")); return Promise.resolve(r) }, u = function (t) { for (var e = "", r = t.length / 2, n = 0; n < r; n++)e += String.fromCharCode(parseInt(t.substr(2 * n, 2), 16)); return Promise.resolve(e) }, f = f || function (t, e) { var r = {}, n = r.lib = {}, i = function () { }, o = n.Base = { extend: function (t) { i.prototype = this; var e = new i; return t && e.mixIn(t), e.hasOwnProperty("init") || (e.init = function () { e.$super.init.apply(this, arguments) }), e.init.prototype = e, e.$super = this, e }, create: function () { var t = this.extend(); return t.init.apply(t, arguments), t }, init: function () { }, mixIn: function (t) { for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]); t.hasOwnProperty("toString") && (this.toString = t.toString) }, clone: function () { return this.init.prototype.extend(this) } }, s = n.WordArray = o.extend({ init: function (t, e) { t = this.words = t || [], this.sigBytes = null != e ? e : 4 * t.length }, toString: function (t) { return (t || a).stringify(this) }, concat: function (t) { var e = this.words, r = t.words, n = this.sigBytes; if (t = t.sigBytes, this.clamp(), n % 4) for (var i = 0; i < t; i++)e[n + i >>> 2] |= (r[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 24 - (n + i) % 4 * 8; else if (65535 < r.length) for (i = 0; i < t; i += 4)e[n + i >>> 2] = r[i >>> 2]; else e.push.apply(e, r); return this.sigBytes += t, this }, clamp: function () { var e = this.words, r = this.sigBytes; e[r >>> 2] &= 4294967295 << 32 - r % 4 * 8, e.length = t.ceil(r / 4) }, clone: function () { var t = o.clone.call(this); return t.words = this.words.slice(0), t }, random: function (e) { for (var r = [], n = 0; n < e; n += 4)r.push(4294967296 * t.random() | 0); return new s.init(r, e) } }), c = r.enc = {}, a = c.Hex = { stringify: function (t) { var e = t.words; t = t.sigBytes; for (var r = [], n = 0; n < t; n++) { var i = e[n >>> 2] >>> 24 - n % 4 * 8 & 255; r.push((i >>> 4).toString(16)), r.push((15 & i).toString(16)) } return r.join("") }, parse: function (t) { for (var e = t.length, r = [], n = 0; n < e; n += 2)r[n >>> 3] |= parseInt(t.substr(n, 2), 16) << 24 - n % 8 * 4; return new s.init(r, e / 2) } }, u = c.Latin1 = { stringify: function (t) { var e = t.words; t = t.sigBytes; for (var r = [], n = 0; n < t; n++)r.push(String.fromCharCode(e[n >>> 2] >>> 24 - n % 4 * 8 & 255)); return r.join("") }, parse: function (t) { for (var e = t.length, r = [], n = 0; n < e; n++)r[n >>> 2] |= (255 & t.charCodeAt(n)) << 24 - n % 4 * 8; return new s.init(r, e) } }, f = c.Utf8 = { stringify: function (t) { try { return decodeURIComponent(escape(u.stringify(t))) } catch (t) { throw Error("Malformed UTF-8 data") } }, parse: function (t) { return u.parse(unescape(encodeURIComponent(t))) } }, h = n.BufferedBlockAlgorithm = o.extend({ reset: function () { this._data = new s.init, this._nDataBytes = 0 }, _append: function (t) { "string" == typeof t && (t = f.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes }, _process: function (e) { var r = this._data, n = r.words, i = r.sigBytes, o = this.blockSize, c = i / (4 * o); if (e = (c = e ? t.ceil(c) : t.max((0 | c) - this._minBufferSize, 0)) * o, i = t.min(4 * e, i), e) { for (var a = 0; a < e; a += o)this._doProcessBlock(n, a); a = n.splice(0, e), r.sigBytes -= i } return new s.init(a, i) }, clone: function () { var t = o.clone.call(this); return t._data = this._data.clone(), t }, _minBufferSize: 0 }); n.Hasher = h.extend({ cfg: o.extend(), init: function (t) { this.cfg = this.cfg.extend(t), this.reset() }, reset: function () { h.reset.call(this), this._doReset() }, update: function (t) { return this._append(t), this._process(), this }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, blockSize: 16, _createHelper: function (t) { return function (e, r) { return new t.init(r).finalize(e) } }, _createHmacHelper: function (t) { return function (e, r) { return new l.HMAC.init(t, r).finalize(e) } } }); var l = r.algo = {}; return r }(Math); return e = (t = f).lib.WordArray, t.enc.Base64 = { stringify: function (t) { var e = t.words, r = t.sigBytes, n = this._map; t.clamp(), t = []; for (var i = 0; i < r; i += 3)for (var o = (e[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (e[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | e[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, s = 0; 4 > s && i + .75 * s < r; s++)t.push(n.charAt(o >>> 6 * (3 - s) & 63)); if (e = n.charAt(64)) for (; t.length % 4;)t.push(e); return t.join("") }, parse: function (t) { var r = t.length, n = this._map; (i = n.charAt(64)) && -1 != (i = t.indexOf(i)) && (r = i); for (var i = [], o = 0, s = 0; s < r; s++)if (s % 4) { var c = n.indexOf(t.charAt(s - 1)) << s % 4 * 2, a = n.indexOf(t.charAt(s)) >>> 6 - s % 4 * 2; i[o >>> 2] |= (c | a) << 24 - o % 4 * 8, o++ } return e.create(i, o) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" }, function (t) { function e(t, e, r, n, i, o, s) { return ((t = t + (e & r | ~e & n) + i + s) << o | t >>> 32 - o) + e } function r(t, e, r, n, i, o, s) { return ((t = t + (e & n | r & ~n) + i + s) << o | t >>> 32 - o) + e } function n(t, e, r, n, i, o, s) { return ((t = t + (e ^ r ^ n) + i + s) << o | t >>> 32 - o) + e } function i(t, e, r, n, i, o, s) { return ((t = t + (r ^ (e | ~n)) + i + s) << o | t >>> 32 - o) + e } for (var o = f, s = (a = o.lib).WordArray, c = a.Hasher, a = o.algo, u = [], h = 0; 64 > h; h++)u[h] = 4294967296 * t.abs(t.sin(h + 1)) | 0; a = a.MD5 = c.extend({ _doReset: function () { this._hash = new s.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function (t, o) { for (var s = 0; 16 > s; s++) { var c = t[a = o + s]; t[a] = 16711935 & (c << 8 | c >>> 24) | 4278255360 & (c << 24 | c >>> 8) } s = this._hash.words; var a = t[o + 0], f = (c = t[o + 1], t[o + 2]), h = t[o + 3], l = t[o + 4], d = t[o + 5], p = t[o + 6], v = t[o + 7], g = t[o + 8], y = t[o + 9], _ = t[o + 10], m = t[o + 11], w = t[o + 12], b = t[o + 13], S = t[o + 14], k = t[o + 15], x = e(x = s[0], E = s[1], M = s[2], B = s[3], a, 7, u[0]), B = e(B, x, E, M, c, 12, u[1]), M = e(M, B, x, E, f, 17, u[2]), E = e(E, M, B, x, h, 22, u[3]); x = e(x, E, M, B, l, 7, u[4]), B = e(B, x, E, M, d, 12, u[5]), M = e(M, B, x, E, p, 17, u[6]), E = e(E, M, B, x, v, 22, u[7]), x = e(x, E, M, B, g, 7, u[8]), B = e(B, x, E, M, y, 12, u[9]), M = e(M, B, x, E, _, 17, u[10]), E = e(E, M, B, x, m, 22, u[11]), x = e(x, E, M, B, w, 7, u[12]), B = e(B, x, E, M, b, 12, u[13]), M = e(M, B, x, E, S, 17, u[14]), x = r(x, E = e(E, M, B, x, k, 22, u[15]), M, B, c, 5, u[16]), B = r(B, x, E, M, p, 9, u[17]), M = r(M, B, x, E, m, 14, u[18]), E = r(E, M, B, x, a, 20, u[19]), x = r(x, E, M, B, d, 5, u[20]), B = r(B, x, E, M, _, 9, u[21]), M = r(M, B, x, E, k, 14, u[22]), E = r(E, M, B, x, l, 20, u[23]), x = r(x, E, M, B, y, 5, u[24]), B = r(B, x, E, M, S, 9, u[25]), M = r(M, B, x, E, h, 14, u[26]), E = r(E, M, B, x, g, 20, u[27]), x = r(x, E, M, B, b, 5, u[28]), B = r(B, x, E, M, f, 9, u[29]), M = r(M, B, x, E, v, 14, u[30]), x = n(x, E = r(E, M, B, x, w, 20, u[31]), M, B, d, 4, u[32]), B = n(B, x, E, M, g, 11, u[33]), M = n(M, B, x, E, m, 16, u[34]), E = n(E, M, B, x, S, 23, u[35]), x = n(x, E, M, B, c, 4, u[36]), B = n(B, x, E, M, l, 11, u[37]), M = n(M, B, x, E, v, 16, u[38]), E = n(E, M, B, x, _, 23, u[39]), x = n(x, E, M, B, b, 4, u[40]), B = n(B, x, E, M, a, 11, u[41]), M = n(M, B, x, E, h, 16, u[42]), E = n(E, M, B, x, p, 23, u[43]), x = n(x, E, M, B, y, 4, u[44]), B = n(B, x, E, M, w, 11, u[45]), M = n(M, B, x, E, k, 16, u[46]), x = i(x, E = n(E, M, B, x, f, 23, u[47]), M, B, a, 6, u[48]), B = i(B, x, E, M, v, 10, u[49]), M = i(M, B, x, E, S, 15, u[50]), E = i(E, M, B, x, d, 21, u[51]), x = i(x, E, M, B, w, 6, u[52]), B = i(B, x, E, M, h, 10, u[53]), M = i(M, B, x, E, _, 15, u[54]), E = i(E, M, B, x, c, 21, u[55]), x = i(x, E, M, B, g, 6, u[56]), B = i(B, x, E, M, k, 10, u[57]), M = i(M, B, x, E, p, 15, u[58]), E = i(E, M, B, x, b, 21, u[59]), x = i(x, E, M, B, l, 6, u[60]), B = i(B, x, E, M, m, 10, u[61]), M = i(M, B, x, E, f, 15, u[62]), E = i(E, M, B, x, y, 21, u[63]); s[0] = s[0] + x | 0, s[1] = s[1] + E | 0, s[2] = s[2] + M | 0, s[3] = s[3] + B | 0 }, _doFinalize: function () { var e = this._data, r = e.words, n = 8 * this._nDataBytes, i = 8 * e.sigBytes; r[i >>> 5] |= 128 << 24 - i % 32; var o = t.floor(n / 4294967296); for (r[15 + (i + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), r[14 + (i + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), e.sigBytes = 4 * (r.length + 1), this._process(), r = (e = this._hash).words, n = 0; 4 > n; n++)i = r[n], r[n] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8); return e }, clone: function () { var t = c.clone.call(this); return t._hash = this._hash.clone(), t } }), o.MD5 = c._createHelper(a), o.HmacMD5 = c._createHmacHelper(a) }(Math), function () { var t, e = f, r = (t = e.lib).Base, n = t.WordArray, i = (t = e.algo).EvpKDF = r.extend({ cfg: r.extend({ keySize: 4, hasher: t.MD5, iterations: 1 }), init: function (t) { this.cfg = this.cfg.extend(t) }, compute: function (t, e) { for (var r = (c = this.cfg).hasher.create(), i = n.create(), o = i.words, s = c.keySize, c = c.iterations; o.length < s;) { a && r.update(a); var a = r.update(t).finalize(e); r.reset(); for (var u = 1; u < c; u++)a = r.finalize(a), r.reset(); i.concat(a) } return i.sigBytes = 4 * s, i } }); e.EvpKDF = function (t, e, r) { return i.create(r).compute(t, e) } }(), f.lib.Cipher || function (t) { var e = (p = f).lib, r = e.Base, n = e.WordArray, i = e.BufferedBlockAlgorithm, o = p.enc.Base64, s = p.algo.EvpKDF, c = e.Cipher = i.extend({ cfg: r.extend(), createEncryptor: function (t, e) { return this.create(this._ENC_XFORM_MODE, t, e) }, createDecryptor: function (t, e) { return this.create(this._DEC_XFORM_MODE, t, e) }, init: function (t, e, r) { this.cfg = this.cfg.extend(r), this._xformMode = t, this._key = e, this.reset() }, reset: function () { i.reset.call(this), this._doReset() }, process: function (t) { return this._append(t), this._process() }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (t) { return { encrypt: function (e, r, n) { return ("string" == typeof r ? v : d).encrypt(t, e, r, n) }, decrypt: function (e, r, n) { return ("string" == typeof r ? v : d).decrypt(t, e, r, n) } } } }); e.StreamCipher = c.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }); var a = p.mode = {}, u = function (t, e, r) { var n = this._iv; n ? this._iv = void 0 : n = this._prevBlock; for (var i = 0; i < r; i++)t[e + i] ^= n[i] }, h = (e.BlockCipherMode = r.extend({ createEncryptor: function (t, e) { return this.Encryptor.create(t, e) }, createDecryptor: function (t, e) { return this.Decryptor.create(t, e) }, init: function (t, e) { this._cipher = t, this._iv = e } })).extend(); h.Encryptor = h.extend({ processBlock: function (t, e) { var r = this._cipher, n = r.blockSize; u.call(this, t, e, n), r.encryptBlock(t, e), this._prevBlock = t.slice(e, e + n) } }), h.Decryptor = h.extend({ processBlock: function (t, e) { var r = this._cipher, n = r.blockSize, i = t.slice(e, e + n); r.decryptBlock(t, e), u.call(this, t, e, n), this._prevBlock = i } }), a = a.CBC = h, h = (p.pad = {}).Pkcs7 = { pad: function (t, e) { for (var r, i = (r = (r = 4 * e) - t.sigBytes % r) << 24 | r << 16 | r << 8 | r, o = [], s = 0; s < r; s += 4)o.push(i); r = n.create(o, r), t.concat(r) }, unpad: function (t) { t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2] } }, e.BlockCipher = c.extend({ cfg: c.cfg.extend({ mode: a, padding: h }), reset: function () { c.reset.call(this); var t = (e = this.cfg).iv, e = e.mode; if (this._xformMode == this._ENC_XFORM_MODE) var r = e.createEncryptor; else r = e.createDecryptor, this._minBufferSize = 1; this._mode = r.call(e, this, t && t.words) }, _doProcessBlock: function (t, e) { this._mode.processBlock(t, e) }, _doFinalize: function () { var t = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { t.pad(this._data, this.blockSize); var e = this._process(!0) } else e = this._process(!0), t.unpad(e); return e }, blockSize: 4 }); var l = e.CipherParams = r.extend({ init: function (t) { this.mixIn(t) }, toString: function (t) { return (t || this.formatter).stringify(this) } }), d = (a = (p.format = {}).OpenSSL = { stringify: function (t) { var e = t.ciphertext; return ((t = t.salt) ? n.create([1398893684, 1701076831]).concat(t).concat(e) : e).toString(o) }, parse: function (t) { var e = (t = o.parse(t)).words; if (1398893684 == e[0] && 1701076831 == e[1]) { var r = n.create(e.slice(2, 4)); e.splice(0, 4), t.sigBytes -= 16 } return l.create({ ciphertext: t, salt: r }) } }, e.SerializableCipher = r.extend({ cfg: r.extend({ format: a }), encrypt: function (t, e, r, n) { n = this.cfg.extend(n); var i = t.createEncryptor(r, n); return e = i.finalize(e), i = i.cfg, l.create({ ciphertext: e, key: r, iv: i.iv, algorithm: t, mode: i.mode, padding: i.padding, blockSize: t.blockSize, formatter: n.format }) }, decrypt: function (t, e, r, n) { return n = this.cfg.extend(n), e = this._parse(e, n.format), t.createDecryptor(r, n).finalize(e.ciphertext) }, _parse: function (t, e) { return "string" == typeof t ? e.parse(t, this) : t } })), p = (p.kdf = {}).OpenSSL = { execute: function (t, e, r, i) { return i || (i = n.random(8)), t = s.create({ keySize: e + r }).compute(t, i), r = n.create(t.words.slice(e), 4 * r), t.sigBytes = 4 * e, l.create({ key: t, iv: r, salt: i }) } }, v = e.PasswordBasedCipher = d.extend({ cfg: d.cfg.extend({ kdf: p }), encrypt: function (t, e, r, n) { return r = (n = this.cfg.extend(n)).kdf.execute(r, t.keySize, t.ivSize), n.iv = r.iv, (t = d.encrypt.call(this, t, e, r.key, n)).mixIn(r), t }, decrypt: function (t, e, r, n) { return n = this.cfg.extend(n), e = this._parse(e, n.format), r = n.kdf.execute(r, t.keySize, t.ivSize, e.salt), n.iv = r.iv, d.decrypt.call(this, t, e, r.key, n) } }) }(), function () { for (var t = f, e = t.lib.BlockCipher, r = t.algo, n = [], i = [], o = [], s = [], c = [], a = [], u = [], h = [], l = [], d = [], p = [], v = 0; 256 > v; v++)p[v] = 128 > v ? v << 1 : v << 1 ^ 283; var g = 0, y = 0; for (v = 0; 256 > v; v++) { var _ = (_ = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4) >>> 8 ^ 255 & _ ^ 99; n[g] = _, i[_] = g; var m = p[g], w = p[m], b = p[w], S = 257 * p[_] ^ 16843008 * _; o[g] = S << 24 | S >>> 8, s[g] = S << 16 | S >>> 16, c[g] = S << 8 | S >>> 24, a[g] = S, S = 16843009 * b ^ 65537 * w ^ 257 * m ^ 16843008 * g, u[_] = S << 24 | S >>> 8, h[_] = S << 16 | S >>> 16, l[_] = S << 8 | S >>> 24, d[_] = S, g ? (g = m ^ p[p[p[b ^ m]]], y ^= p[p[y]]) : g = y = 1 } var k = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]; r = r.AES = e.extend({ _doReset: function () { for (var t = (r = this._key).words, e = r.sigBytes / 4, r = 4 * ((this._nRounds = e + 6) + 1), i = this._keySchedule = [], o = 0; o < r; o++)if (o < e) i[o] = t[o]; else { var s = i[o - 1]; o % e ? 6 < e && 4 == o % e && (s = n[s >>> 24] << 24 | n[s >>> 16 & 255] << 16 | n[s >>> 8 & 255] << 8 | n[255 & s]) : (s = n[(s = s << 8 | s >>> 24) >>> 24] << 24 | n[s >>> 16 & 255] << 16 | n[s >>> 8 & 255] << 8 | n[255 & s], s ^= k[o / e | 0] << 24), i[o] = i[o - e] ^ s } for (t = this._invKeySchedule = [], e = 0; e < r; e++)o = r - e, s = e % 4 ? i[o] : i[o - 4], t[e] = 4 > e || 4 >= o ? s : u[n[s >>> 24]] ^ h[n[s >>> 16 & 255]] ^ l[n[s >>> 8 & 255]] ^ d[n[255 & s]] }, encryptBlock: function (t, e) { this._doCryptBlock(t, e, this._keySchedule, o, s, c, a, n) }, decryptBlock: function (t, e) { var r = t[e + 1]; t[e + 1] = t[e + 3], t[e + 3] = r, this._doCryptBlock(t, e, this._invKeySchedule, u, h, l, d, i), r = t[e + 1], t[e + 1] = t[e + 3], t[e + 3] = r }, _doCryptBlock: function (t, e, r, n, i, o, s, c) { for (var a = this._nRounds, u = t[e] ^ r[0], f = t[e + 1] ^ r[1], h = t[e + 2] ^ r[2], l = t[e + 3] ^ r[3], d = 4, p = 1; p < a; p++) { var v = n[u >>> 24] ^ i[f >>> 16 & 255] ^ o[h >>> 8 & 255] ^ s[255 & l] ^ r[d++], g = n[f >>> 24] ^ i[h >>> 16 & 255] ^ o[l >>> 8 & 255] ^ s[255 & u] ^ r[d++], y = n[h >>> 24] ^ i[l >>> 16 & 255] ^ o[u >>> 8 & 255] ^ s[255 & f] ^ r[d++]; l = n[l >>> 24] ^ i[u >>> 16 & 255] ^ o[f >>> 8 & 255] ^ s[255 & h] ^ r[d++], u = v, f = g, h = y } v = (c[u >>> 24] << 24 | c[f >>> 16 & 255] << 16 | c[h >>> 8 & 255] << 8 | c[255 & l]) ^ r[d++], g = (c[f >>> 24] << 24 | c[h >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & u]) ^ r[d++], y = (c[h >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[u >>> 8 & 255] << 8 | c[255 & f]) ^ r[d++], l = (c[l >>> 24] << 24 | c[u >>> 16 & 255] << 16 | c[f >>> 8 & 255] << 8 | c[255 & h]) ^ r[d++], t[e] = v, t[e + 1] = g, t[e + 2] = y, t[e + 3] = l }, keySize: 8 }); t.AES = e._createHelper(r) }(), { isInitializationDone: !1, ecrp: o, dcrp: s, hecrp: function (t) { return o(t).then(function (t) { return a(t) }) }, hdcrp: function (t) { return u(t).then(function (t) { return s(t) }) }, hexenc: a, hexdec: u, setV: c, sRV: function (t, e, n, o) { var s = "&", a = "!"; s += t.charCodeAt(1) + "a"; var u = i(); s += "#" + t.charCodeAt(0), a += t.charCodeAt(2); var f = i(e, n, o); s += t.charCodeAt(5); var h = f - u; s += h % e, a += h / e, s += h.toString(); a = (a += t.charCodeAt(4) + h.toString()).substr(0, 16), s = s.substr(0, 15); c(s += ".", a), r.KeyMethod = "generated" }, getVersion: function () { return "1.0.2" } } }(), function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.ES6Promise = e() }(this, function () { "use strict"; function t(t) { return "function" == typeof t } function e() { var t = setTimeout; return function () { return t(r, 1) } } function r() { for (var t = 0; t < g; t += 2) { (0, B[t])(B[t + 1]), B[t] = void 0, B[t + 1] = void 0 } g = 0 } function n(t, e) { var r = this, n = new this.constructor(o); void 0 === n[E] && p(n); var i = r._state; if (i) { var s = arguments[i - 1]; m(function () { return d(i, n, s, r._result) }) } else h(r, n, t, e); return n } function i(t) { if (t && "object" == typeof t && t.constructor === this) return t; var e = new this(o); return c(e, t), e } function o() { } function s(e, r, o) { r.constructor === e.constructor && o === n && r.constructor.resolve === i ? function (t, e) { e._state === C ? u(t, e._result) : e._state === z ? f(t, e._result) : h(e, void 0, function (e) { return c(t, e) }, function (e) { return f(t, e) }) }(e, r) : void 0 === o ? u(e, r) : t(o) ? function (t, e, r) { m(function (t) { var n = !1, i = function (t, e, r, n) { try { t.call(e, r, n) } catch (t) { return t } }(r, e, function (r) { n || (n = !0, e !== r ? c(t, r) : u(t, r)) }, function (e) { n || (n = !0, f(t, e)) }, t._label); !n && i && (n = !0, f(t, i)) }, t) }(e, r, o) : u(e, r) } function c(t, e) { if (t === e) f(t, new TypeError("You cannot resolve a promise with itself")); else if (function (t) { var e = typeof t; return null !== t && ("object" === e || "function" === e) }(e)) { var r = void 0; try { r = e.then } catch (e) { return void f(t, e) } s(t, e, r) } else u(t, e) } function a(t) { t._onerror && t._onerror(t._result), l(t) } function u(t, e) { t._state === A && (t._result = e, t._state = C, 0 !== t._subscribers.length && m(l, t)) } function f(t, e) { t._state === A && (t._state = z, t._result = e, m(a, t)) } function h(t, e, r, n) { var i = t._subscribers, o = i.length; t._onerror = null, i[o] = e, i[o + C] = r, i[o + z] = n, 0 === o && t._state && m(l, t) } function l(t) { var e = t._subscribers, r = t._state; if (0 !== e.length) { for (var n = void 0, i = void 0, o = t._result, s = 0; s < e.length; s += 3)n = e[s], i = e[s + r], n ? d(r, n, i, o) : i(o); t._subscribers.length = 0 } } function d(e, r, n, i) { var o = t(n), s = void 0, a = void 0, h = !0; if (o) { try { s = n(i) } catch (t) { h = !1, a = t } if (r === s) return void f(r, new TypeError("A promises callback cannot return that same promise.")) } else s = i; r._state !== A || (o && h ? c(r, s) : !1 === h ? f(r, a) : e === C ? u(r, s) : e === z && f(r, s)) } function p(t) { t[E] = D++, t._state = void 0, t._result = void 0, t._subscribers = [] } var v = Array.isArray ? Array.isArray : function (t) { return "[object Array]" === Object.prototype.toString.call(t) }, g = 0, y = void 0, _ = void 0, m = function (t, e) { B[g] = t, B[g + 1] = e, 2 === (g += 2) && (_ ? _(r) : M()) }, w = "undefined" != typeof window ? window : void 0, b = w || {}, S = b.MutationObserver || b.WebKitMutationObserver, k = "undefined" == typeof self && "undefined" != typeof process && "[object process]" === {}.toString.call(process), x = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, B = new Array(1e3), M = void 0; M = k ? function () { return process.nextTick(r) } : S ? function () { var t = 0, e = new S(r), n = document.createTextNode(""); return e.observe(n, { characterData: !0 }), function () { n.data = t = ++t % 2 } }() : x ? function () { var t = new MessageChannel; return t.port1.onmessage = r, function () { return t.port2.postMessage(0) } }() : void 0 === w && "function" == typeof require ? function () { try { var t = Function("return this")().require("vertx"); return void 0 !== (y = t.runOnLoop || t.runOnContext) ? function () { y(r) } : e() } catch (t) { return e() } }() : e(); var E = Math.random().toString(36).substring(2), A = void 0, C = 1, z = 2, D = 0, O = function () { function t(t, e) { this._instanceConstructor = t, this.promise = new t(o), this.promise[E] || p(this.promise), v(e) ? (this.length = e.length, this._remaining = e.length, this._result = new Array(this.length), 0 === this.length ? u(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(e), 0 === this._remaining && u(this.promise, this._result))) : f(this.promise, new Error("Array Methods must be provided an Array")) } return t.prototype._enumerate = function (t) { for (var e = 0; this._state === A && e < t.length; e++)this._eachEntry(t[e], e) }, t.prototype._eachEntry = function (t, e) { var r = this._instanceConstructor, c = r.resolve; if (c === i) { var a = void 0, u = void 0, h = !1; try { a = t.then } catch (t) { h = !0, u = t } if (a === n && t._state !== A) this._settledAt(t._state, e, t._result); else if ("function" != typeof a) this._remaining--, this._result[e] = t; else if (r === U) { var l = new r(o); h ? f(l, u) : s(l, t, a), this._willSettleAt(l, e) } else this._willSettleAt(new r(function (e) { return e(t) }), e) } else this._willSettleAt(c(t), e) }, t.prototype._settledAt = function (t, e, r) { var n = this.promise; n._state === A && (this._remaining--, t === z ? f(n, r) : this._result[e] = r), 0 === this._remaining && u(n, this._result) }, t.prototype._willSettleAt = function (t, e) { var r = this; h(t, void 0, function (t) { return r._settledAt(C, e, t) }, function (t) { return r._settledAt(z, e, t) }) }, t }(), U = function () { function e(t) { this[E] = D++, this._result = this._state = void 0, this._subscribers = [], o !== t && ("function" != typeof t && function () { throw new TypeError("You must pass a resolver function as the first argument to the promise constructor") }(), this instanceof e ? function (t, e) { try { e(function (e) { c(t, e) }, function (e) { f(t, e) }) } catch (e) { f(t, e) } }(this, t) : function () { throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.") }()) } return e.prototype.catch = function (t) { return this.then(null, t) }, e.prototype.finally = function (e) { var r = this, n = r.constructor; return t(e) ? r.then(function (t) { return n.resolve(e()).then(function () { return t }) }, function (t) { return n.resolve(e()).then(function () { throw t }) }) : r.then(e, e) }, e }(); return U.prototype.then = n, U.all = function (t) { return new O(this, t).promise }, U.race = function (t) { var e = this; return new e(v(t) ? function (r, n) { for (var i = t.length, o = 0; o < i; o++)e.resolve(t[o]).then(r, n) } : function (t, e) { return e(new TypeError("You must pass an array to race.")) }) }, U.resolve = i, U.reject = function (t) { var e = new this(o); return f(e, t), e }, U._setScheduler = function (t) { _ = t }, U._setAsap = function (t) { m = t }, U._asap = m, U.polyfill = function () { var t = void 0; if ("undefined" != typeof global) t = global; else if ("undefined" != typeof self) t = self; else try { t = Function("return this")() } catch (t) { throw new Error("polyfill failed because global object is unavailable in this environment") } var e = t.Promise; if (e) { var r = null; try { r = Object.prototype.toString.call(e.resolve()) } catch (t) { } if ("[object Promise]" === r && !e.cast) return } t.Promise = U }, U.Promise = U, U.polyfill(), U }), Array.from || (Array.from = function () { var t = Object.prototype.toString, e = function (e) { return "function" == typeof e || "[object Function]" === t.call(e) }, r = Math.pow(2, 53) - 1, n = function (t) { var e = function (t) { var e = Number(t); return isNaN(e) ? 0 : 0 !== e && isFinite(e) ? (e > 0 ? 1 : -1) * Math.floor(Math.abs(e)) : e }(t); return Math.min(Math.max(e, 0), r) }; return function (t) { var r = Object(t); if (null == t) throw new TypeError("Array.from requires an array-like object - not null or undefined"); var i, o = arguments.length > 1 ? arguments[1] : void 0; if (void 0 !== o) { if (!e(o)) throw new TypeError("Array.from: when provided, the second argument must be a function"); arguments.length > 2 && (i = arguments[2]) } for (var s, c = n(r.length), a = e(this) ? Object(new this(c)) : new Array(c), u = 0; u < c;)s = r[u], a[u] = o ? void 0 === i ? o(s, u) : o.call(i, s, u) : s, u += 1; return a.length = c, a } }()), String.prototype.padStart || (String.prototype.padStart = function (t, e) { return t >>= 0, e = String(void 0 !== e ? e : " "), this.length > t ? String(this) : ((t -= this.length) > e.length && (e += e.repeat(t / e.length)), e.slice(0, t) + String(this)) }), String.prototype.repeat || (String.prototype.repeat = function (t) { "use strict"; if (null == this) throw new TypeError("can't convert " + this + " to object"); var e = "" + this; if ((t = +t) != t && (t = 0), t < 0) throw new RangeError("repeat count must be non-negative"); if (t == 1 / 0) throw new RangeError("repeat count must be less than infinity"); if (t = Math.floor(t), 0 == e.length || 0 == t) return ""; if (e.length * t >= 1 << 28) throw new RangeError("repeat count must not overflow maximum string size"); var r = e.length * t; for (t = Math.floor(Math.log(t) / Math.log(2)); t;)e += e, t--; return e += e.substring(0, r - e.length) });